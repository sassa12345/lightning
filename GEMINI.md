オンラインウェブカードゲーム企画書：カードバトルロイヤル
1. ゲーム概要
「カードバトルロイヤル」は、2〜15人のプレイヤーで手軽に楽しめるオンライン対戦型カードゲームです。ランダムに配られるカードを駆使し、戦略的に相手プレイヤーを攻撃したり、自分を強化したりしながら、最後の1人を目指します。シンプルながらも奥深い戦略性と、多人数での予測不能な展開が魅力です。

2. ゲームシステム
2.1. 基本ルール
参加人数: 2人〜15人

勝利条件: 最後の1人になる

HP制:

最大HP: 30

初期HP: 30

カード:

初期手札: 各プレイヤーにランダムで3枚配布

毎ターンの開始時: デッキから1枚ドロー（最初の手札配布以外で）

カードの種類: 攻撃、シールド、回復、チャージの4タイプ

カードの使用: 1ターンに1枚使用可能（一部例外あり）

2.2. ターンの流れ
ターンの開始: ランダムな順番でプレイヤーのターンが開始されます。

カードドロー: デッキからカードを1枚引きます。

カードの使用: 手札からカードを1枚選び、自分に使用するか、他のプレイヤーを対象として使用します。

攻撃カード: 指定したプレイヤーにダメージを与えます。攻撃相手はプレイヤーが選択できます。

通常攻撃1〜5 (出現率 35%):

通常攻撃1: 攻撃力 2

通常攻撃2: 攻撃力 4

通常攻撃3: 攻撃力 6

通常攻撃4: 攻撃力 8

通常攻撃5: 攻撃力 10

バイオハザード (出現率 10%): 攻撃力 15

アーマーピーサー (出現率 5%): 攻撃力 6。この攻撃はシールドを無視して直接HPにダメージを与えます。

シールドカード: 自身へのダメージを軽減、または無効化します。

シールド (出現率 20%): **10ポイントのシールドを張ります。**シールドはHPの前にダメージを受け止め、0になると消滅します。

回復カード: 自身のHPを回復します。

通常回復1〜3 (出現率 20%):

通常回復1: HP回復 2

通常回復2: HP回復 4

通常回復3: HP回復 6

自動回復 (出現率 5%): このカードを使ったターンから、以降毎ターン開始時にHPが3回復します。

なかよし (出現率 5%): このカードを使用すると、自分のHPがランダムに選ばれた相手プレイヤーの現在のHPと同じになります。

チャージカード: 手札のカードを強化します。

チャージ1〜3 (出現率 10%): このカードを使用すると、自分の手札にあるすべてのカードの数値が上がります。

チャージ1: 数値が2上がる

チャージ2: 数値が3上がる

チャージ3: 数値が4上がる

（例：攻撃カードの攻撃力、回復カードの回復量、シールドカードのシールド量が対象となります。）

攻撃制限（4人以上の場合）: 生き残っている人数が4人以上の場合、同じプレイヤーに2回連続で攻撃することはできません。（攻撃するプレイヤーが異なる場合でも適用されます。）

ターンの終了: 次のプレイヤーにターンが移ります。毎自分のターン終了後、自分の手持ちのカードがすべて2チャージされます。この自動チャージは、攻撃、シールド、回復、そしてチャージカードを含むすべてのカードに適用されます。

HPが0になった場合: そのプレイヤーはゲームから脱落します。

3. オンライン対戦機能
3.1. 自動マッチング
「今すぐプレイ」ボタンをクリックすることで、自動的に現在募集中のゲームに参加できます。

人数が揃い次第、自動的にゲームが開始されます。

3.2. プライベートマッチ
ルーム作成機能: 特定のパスワードを設定し、友人同士で遊べるプライベートなルームを作成できます。

ルーム検索・参加機能: パスワードを入力することで、既存のプライベートマッチに参加できます。

4. 超詳細な実装チェックリスト (JSON & メモリベース)
このセクションでは、データベースを使わず、JSONファイルとサーバーメモリ上でゲームの状態を管理する前提で、実装の各ステップを細かく分解したチェックリストを提供します。

4.1. 全体構成 & 環境構築
開発環境セットアップ

[x] Node.js と npm (またはYarn) をインストールする。

[x] Gitリポジトリを作成し、バージョン管理を開始する。

[x] プロジェクトフォルダ構造を決定する（例: server/, client/, shared/, data/）。

[ ] VS Code などのエディタと、必要な拡張機能（ESLint, Prettierなど）を設定する。

主要なライブラリのインストール

[x] サーバー側:

express: Webサーバーフレームワーク

socket.io: WebSocketによるリアルタイム通信

cors: クロスオリジンリソース共有対策 (開発時)

uuid: ユニークID生成

dotenv: 環境変数管理 (必要に応じて)

[x] クライアント側:

react / vue / svelte: UIフレームワーク

socket.io-client: WebSocketクライアント

react-router-dom / vue-router: ルーティング (必要に応じて)

[ ] pixi.js / phaser: 2Dレンダリングエンジン (リッチなアニメーションが必要な場合)

4.2. データ定義 (JSONファイル)
カードデータ定義 (data/cards.json など)

[x] 全てのカードタイプ (攻撃、シールド、回復、チャージ) を定義する。

[x] 各カードの属性を定義する:

id: カードの一意のID (例: "attack_normal_1", "heal_auto")

name: カード名 (例: "通常攻撃1", "自動回復")

type: カードのタイプ (例: "attack", "shield", "heal", "charge")

baseValue: カードの基本数値 (攻撃力、回復量、シールド量、チャージ量など)

probability: 調整後の出現率（合計100%になるように設定済み）

通常攻撃1〜5: 35% (各7%)

バイオハザード: 10%

アーマーピーサー: 5%

シールド: 20%

通常回復1〜3: 20% (各約6.67%)

自動回復: 5%

なかよし: 5%

チャージ1〜3: 10% (各約3.33%)

description: カード効果の説明文

isPiercing (攻撃カードのみ): true ならアーマーピーサー（初期値: false）

isPersistent (回復カードのみ): true なら自動回復（初期値: false）

isHpShare (回復カードのみ): true なら「なかよし」（初期値: false）

[x] 各カードタイプのサブタイプ（例：通常攻撃1～5など）も個別に定義し、出現率を考慮に入れる。

[x] カードのチャージによる数値変化のルールを定義：

[x] 攻撃カード: baseValue (攻撃力) がチャージ量分増加する。

[x] シールドカード: baseValue (シールド量) がチャージ量分増加する。

[x] 回復カード: baseValue (回復量) がチャージ量分増加する。（自動回復, なかよしはチャージの影響を受けない、あるいは影響するパラメータを定義する）

[x] チャージカード: baseValue (チャージ量) がチャージ量分増加する。

4.3. バックエンド (サーバー) 実装
サーバーの初期設定 (server/app.js または server/index.js)

[x] Expressサーバーを起動し、静的ファイル（フロントエンドビルド）を配信する。

[x] Socket.IOサーバーを初期化し、Expressサーバーに紐付ける。

[x] CORS設定を行う（開発時のみ）。

[x] JSONファイルからカードデータを読み込み、メモリに保持する。

ゲームの状態管理 (サーバーメモリ)

[x] games オブジェクト/Mapを定義し、現在進行中の全てのゲームを格納する。キーは gameId。

gameId: string

players: Player[]

currentTurnPlayerId: string

turnOrder: string[] (プレイヤーIDの配列)

lastAttackedPlayerRecord: Map<string, string> (キー: ターゲットプレイヤーID, 値: 直前の攻撃者ID。4人以上の場合の連続攻撃制限用)

gamePhase: string (例: "waiting", "playing", "ended")

[ ] chatLog: object[]

[ ] gameLog: object[] (ターンの詳細ログ)

nextCardInstanceId: number (カードインスタンスに一意のIDを付与するため)

[x] Player オブジェクトの型/インターフェースを定義:

id: string (Socket.IOのソケットIDなど、プレイヤー識別用)

name: string (プレイヤーが入力する名前)

hp: number (現在のHP)

shield: number (現在のシールド量)

hand: CardInstance[] (手札のカードオブジェクトの配列。CardInstanceにはCardのプロパティに加え、currentValue, instanceIdなどを含む)

deck: string[] (デッキにあるカードの基本IDの配列)

discardPile: CardInstance[] (捨て札にあるカードインスタンスの配列)

activeEffects: { type: string, value: number }[] (自動回復など、持続効果の状態)

Socket.IO イベントハンドリング

接続/切断:

[x] connection イベント: 新規プレイヤーが接続したときの処理（ソケットIDとユーザー名などを紐付け）。

[x] disconnect イベント: プレイヤーが切断したときの処理（参加ルームからの除外、ルームの削除など）。

ルーム管理:

[x] createRoom イベント:

[x] ユニークな gameId とパスワードを生成する。

[x] 新しいゲーム状態オブジェクトを games に追加する。

[x] プレイヤーをルームに参加させる（Socket.IOのルーム機能を使用）。

[x] ルーム情報をクライアントに送信する。

[x] joinRoom イベント:

[x] gameId とパスワードを検証する。

[x] プレイヤーをルームに参加させる。

[x] ルームの現在の状態を新規参加プレイヤーに送信する。

[x] 既存プレイヤーに新規参加を通知する。

[x] leaveRoom イベント:

[x] プレイヤーをゲームから除外する。

[x] ゲームにプレイヤーが残っていない場合、ゲーム状態をメモリから削除する。

ゲーム開始:

[x] startGame イベント (ルーム作成者から):

[x] 参加人数が最小要件 (2人) を満たしているか確認する。

[x] 各プレイヤーのHPを初期化し、シールドを0にする。

[x] デッキ生成: cards.json から全てのカードIDを出現率に基づいて、各プレイヤーのデッキにシャッフルして格納する。この際、カードインスタンスIDを付与する。

[x] 初期手札配布: 各プレイヤーにランダムで3枚のカードをデッキから引かせ、手札に移動させる。

[x] ターンの順番をランダムに決定し、turnOrderに設定する。

[x] 最初のターンプレイヤーを決定し、ターンを開始する。

[x] ゲーム状態を全クライアントにブロードキャストする (io.to(gameId).emit('gameStateUpdate', games[gameId]))。

ターンの進行:

[x] playCard イベント (プレイヤーがカードを使用した時):

[x] カードを使用したのが現在のターンプレイヤーか確認する。

[x] 指定された cardInstanceId が手札にあるか確認する。

[x] カードタイプごとの効果処理関数を呼び出す:

攻撃カード:

[x] targetPlayerId の検証（ターゲットが存在し、自分ではないかなど）。

[x] 攻撃制限チェック (4人以上の場合): lastAttackedPlayerRecord を参照し、targetPlayerId が直前の攻撃対象ではないか確認する。

[x] ターゲットのシールドを適用する（isPiercing の場合は無視）。

[x] ターゲットのHPを減少させる。

[x] HPが0になった場合、そのプレイヤーを脱落させる (eliminatedPlayers リストに追加など)。

[x] lastAttackedPlayerRecord を更新する。

シールドカード:

[x] プレイヤーのシールド値をカードのcurrentValue分増加させる。

回復カード:

[x] プレイヤーのHPをカードのcurrentValue分回復させる（最大HP30を超えないように）。

[x] 「自動回復」の場合、プレイヤーのactiveEffects に追加する。

[x] 「なかよし」の場合、ランダムな相手プレイヤーを選択し、自分のHPをその相手のHPと同期させる。

チャージカード:

[x] プレイヤーの**手札にある全てのカードのcurrentValue**を、使用したチャージカードのcurrentValue分増加させる。

[x] 使用したカードを手札から削除し、捨て札に追加する。

[x] ゲーム状態を全クライアントにブロードキャストする。

[x] ターン終了処理を開始する (endTurn 内部関数を呼び出す)。

[ ] passTurn イベント (プレイヤーがカードを使用せずターンを終了する場合):

[ ] 現在のターンプレイヤーか確認する。

[ ] ターン終了処理を開始する。

[x] ターン終了処理 (endTurn 内部関数):

[x] 現在のターンプレイヤーの手札にある全てのカードのcurrentValueを2チャージする。

[x] 持続効果の処理: プレイヤーのactiveEffectsを適用する（例: 「自動回復」によるHP回復）。

[x] 勝利条件をチェックする（残りが1人か）。

[x] 勝利者がいた場合、ゲーム終了処理を実行する。

[x] 次のターンプレイヤーに移行する（脱落したプレイヤーはスキップ）。

[x] 新しいターンプレイヤーにデッキからカードを1枚引かせる。デッキが空の場合、捨て札をシャッフルして新しいデッキとする。

[x] ゲーム状態を全クライアントにブロードキャストする。

ゲーム終了処理 (endGame 関数):

[x] 勝者を決定する。

[ ] ゲームの結果（勝者、各プレイヤーの最終HP、ゲームログなど）をJSONファイルとしてサーバーの指定ディレクトリに保存する。

[x] 関連するゲームの状態をメモリから削除する。

[x] 全クライアントにゲーム終了と結果を通知する。

チャット機能:

[ ] sendMessage イベント: メッセージを受信し、ゲームのchatLogに追加後、全クライアントにブロードキャストする。

4.4. フロントエンド (クライアント) 実装
初期設定 (client/src/index.js または App.js)

[x] Socket.IOクライアントを初期化し、サーバーに接続する。

UIコンポーネント作成

[x] メイン画面 (Lobby.js など):

[ ] 「今すぐプレイ」ボタン

[x] 「プライベートマッチ作成」ボタンとユーザー名入力フィールド

[x] 「プライベートマッチ参加」ボタン、ルームID入力フィールド、パスワード入力フィールド

[x] ゲーム画面 (GameArena.js など):

[x] プレイヤーリスト: 各プレイヤーのアイコン、名前、HP、シールド量を表示するコンポーネント。HP/シールドの増減を視覚的に示すアニメーション。

[x] 攻撃対象選択時にプレイヤーをハイライト表示するUI。

[x] 自分の手札: カードの画像、名前、効果、現在の数値（チャージ量含む）を表示するコンポーネント。

[x] カードの使用時にドラッグ＆ドロップまたはクリックで選択できるようにする。

[ ] カード使用時のアニメーション。

[ ] ゲームボード/ログ:

[ ] リアルタイムなゲームログ（「〇〇が××に攻撃し、△△ダメージ！」など）。

[ ] カード使用時のエフェクト、攻撃アニメーション、HP/シールドの視覚的変化。

[x] ターン表示: 現在のターンプレイヤーを明確に示すUI。

[ ] チャットウィンドウ: メッセージ入力欄と表示エリア。

Socket.IO イベントリスナー (クライアント)

[x] connect, disconnect イベント: 接続状態のUI表示。

[x] roomCreated, roomJoined, roomInfo: ルーム情報の更新、ゲーム開始待機画面への遷移。

[x] gameStarted: ゲーム開始時のUI初期化、ボードの描画。

[x] gameStateUpdate: サーバーからのゲーム状態の更新を常にリッスンし、UIにリアルタイムで反映する。

[x] HP/シールドの変動、手札の更新（カードのcurrentValueを含む）、ターンプレイヤーの切り替えなどを正確に表示。

[ ] カードの数値変化を視覚的に分かりやすく表示（例: 数字の色を変える、光らせるなど）。

[x] playerEliminated: プレイヤー脱落時のエフェクトと表示。

[x] gameEnded: ゲーム終了時の結果表示、ロビーへの遷移。

[ ] chatMessage: チャットメッセージをUIに追加表示する。

ユーザーインタラクション

[x] ボタンクリック、カード選択（クリック/ドラッグ）、ターゲット選択などのUIイベントを捕捉し、対応するSocket.IOイベント (playCard, passTurn, sendMessageなど) をサーバーに送信する。

4.5. 品質保証 & デプロイ
テスト:

[ ] ユニットテスト: 各カード効果の計算、デッキシャッフル、チャージ計算、HP/シールドの増減など、個別のロジックの正確性をテストする。

[ ] 統合テスト: クライアントとサーバー間の通信、ゲームのターン進行が正しく機能するかをテストする。

[ ] 多人数テスト: 複数プレイヤーでの同時接続、カード使用、攻撃制限が正しく動作するかをテストする（2人、4人、最大人数で試す）。

[ ] エラーハンドリング: 無効な操作、ネットワーク切断、サーバーダウンなどに対するサーバー・クライアントの挙動を確認し、適切なエラーメッセージを表示する。

[ ] パフォーマンステスト: 多人数での同時プレイ時に、ゲームの遅延が発生しないか、サーバーリソースが逼迫しないかを確認する。

デプロイ:

[ ] Heroku, Render, GlitchなどのPaaS (Platform as a Service) を選定する。

[ ] デプロイ設定ファイル (Procfile, package.json のスクリプトなど) を準備する。

[ ] HTTPS/WSS (WebSocket Secure) の設定を行う（本番環境でのセキュリティのため）。

[ ] ロギングとモニタリングを設定し、問題発生時に対応できるようにする。

GEMINI.mdのチェックボックスに実装完了したら印をつけ、上から実装する